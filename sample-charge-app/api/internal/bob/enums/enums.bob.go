// Code generated by BobGen mysql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package enums

import (
	"database/sql/driver"
	"fmt"
)

// Enum values for CatalogPricesBillingCycle
const (
	CatalogPricesBillingCycleMonthly   CatalogPricesBillingCycle = "MONTHLY"
	CatalogPricesBillingCycleYearly    CatalogPricesBillingCycle = "YEARLY"
	CatalogPricesBillingCycleQuarterly CatalogPricesBillingCycle = "QUARTERLY"
)

func AllCatalogPricesBillingCycle() []CatalogPricesBillingCycle {
	return []CatalogPricesBillingCycle{
		CatalogPricesBillingCycleMonthly,
		CatalogPricesBillingCycleYearly,
		CatalogPricesBillingCycleQuarterly,
	}
}

type CatalogPricesBillingCycle string

func (e CatalogPricesBillingCycle) String() string {
	return string(e)
}

func (e CatalogPricesBillingCycle) Valid() bool {
	switch e {
	case CatalogPricesBillingCycleMonthly,
		CatalogPricesBillingCycleYearly,
		CatalogPricesBillingCycleQuarterly:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e CatalogPricesBillingCycle) All() []CatalogPricesBillingCycle {
	return AllCatalogPricesBillingCycle()
}

func (e CatalogPricesBillingCycle) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *CatalogPricesBillingCycle) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e CatalogPricesBillingCycle) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *CatalogPricesBillingCycle) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e CatalogPricesBillingCycle) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *CatalogPricesBillingCycle) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = CatalogPricesBillingCycle(x)
	case []byte:
		*e = CatalogPricesBillingCycle(x)
	case nil:
		return fmt.Errorf("cannot nil into CatalogPricesBillingCycle")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid CatalogPricesBillingCycle value: %s", *e)
	}

	return nil
}

// Enum values for CatalogPricesBillingType
const (
	CatalogPricesBillingTypeOneShot   CatalogPricesBillingType = "ONE_SHOT"
	CatalogPricesBillingTypeRecurring CatalogPricesBillingType = "RECURRING"
)

func AllCatalogPricesBillingType() []CatalogPricesBillingType {
	return []CatalogPricesBillingType{
		CatalogPricesBillingTypeOneShot,
		CatalogPricesBillingTypeRecurring,
	}
}

type CatalogPricesBillingType string

func (e CatalogPricesBillingType) String() string {
	return string(e)
}

func (e CatalogPricesBillingType) Valid() bool {
	switch e {
	case CatalogPricesBillingTypeOneShot,
		CatalogPricesBillingTypeRecurring:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e CatalogPricesBillingType) All() []CatalogPricesBillingType {
	return AllCatalogPricesBillingType()
}

func (e CatalogPricesBillingType) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *CatalogPricesBillingType) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e CatalogPricesBillingType) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *CatalogPricesBillingType) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e CatalogPricesBillingType) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *CatalogPricesBillingType) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = CatalogPricesBillingType(x)
	case []byte:
		*e = CatalogPricesBillingType(x)
	case nil:
		return fmt.Errorf("cannot nil into CatalogPricesBillingType")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid CatalogPricesBillingType value: %s", *e)
	}

	return nil
}

// Enum values for ServiceChargeStatusesStatus
const (
	ServiceChargeStatusesStatusReserved  ServiceChargeStatusesStatus = "RESERVED"
	ServiceChargeStatusesStatusCompleted ServiceChargeStatusesStatus = "COMPLETED"
	ServiceChargeStatusesStatusFailed    ServiceChargeStatusesStatus = "FAILED"
	ServiceChargeStatusesStatusCancelled ServiceChargeStatusesStatus = "CANCELLED"
)

func AllServiceChargeStatusesStatus() []ServiceChargeStatusesStatus {
	return []ServiceChargeStatusesStatus{
		ServiceChargeStatusesStatusReserved,
		ServiceChargeStatusesStatusCompleted,
		ServiceChargeStatusesStatusFailed,
		ServiceChargeStatusesStatusCancelled,
	}
}

type ServiceChargeStatusesStatus string

func (e ServiceChargeStatusesStatus) String() string {
	return string(e)
}

func (e ServiceChargeStatusesStatus) Valid() bool {
	switch e {
	case ServiceChargeStatusesStatusReserved,
		ServiceChargeStatusesStatusCompleted,
		ServiceChargeStatusesStatusFailed,
		ServiceChargeStatusesStatusCancelled:
		return true
	default:
		return false
	}
}

// useful when testing in other packages
func (e ServiceChargeStatusesStatus) All() []ServiceChargeStatusesStatus {
	return AllServiceChargeStatusesStatus()
}

func (e ServiceChargeStatusesStatus) MarshalText() ([]byte, error) {
	return []byte(e), nil
}

func (e *ServiceChargeStatusesStatus) UnmarshalText(text []byte) error {
	return e.Scan(text)
}

func (e ServiceChargeStatusesStatus) MarshalBinary() ([]byte, error) {
	return []byte(e), nil
}

func (e *ServiceChargeStatusesStatus) UnmarshalBinary(data []byte) error {
	return e.Scan(data)
}

func (e ServiceChargeStatusesStatus) Value() (driver.Value, error) {
	return string(e), nil
}

func (e *ServiceChargeStatusesStatus) Scan(value any) error {
	switch x := value.(type) {
	case string:
		*e = ServiceChargeStatusesStatus(x)
	case []byte:
		*e = ServiceChargeStatusesStatus(x)
	case nil:
		return fmt.Errorf("cannot nil into ServiceChargeStatusesStatus")
	default:
		return fmt.Errorf("cannot scan type %T: %v", value, value)
	}

	if !e.Valid() {
		return fmt.Errorf("invalid ServiceChargeStatusesStatus value: %s", *e)
	}

	return nil
}
