// Code generated by BobGen mysql v0.42.0. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"database/sql"
	"time"

	enums "github.com/flora/api/internal/bob/enums"
	models "github.com/flora/api/internal/bob/models"
	"github.com/stephenafamo/bob/types"
)

type Factory struct {
	baseAccountMods             AccountModSlice
	baseCatalogPriceMods        CatalogPriceModSlice
	baseCatalogMods             CatalogModSlice
	baseOneShotUsageMods        OneShotUsageModSlice
	baseSchemaMigrationMods     SchemaMigrationModSlice
	baseServiceChargeItemMods   ServiceChargeItemModSlice
	baseServiceChargeStatusMods ServiceChargeStatusModSlice
	baseServiceChargeMods       ServiceChargeModSlice
	baseSubscriptionMods        SubscriptionModSlice
	baseTenantMods              TenantModSlice
}

func New() *Factory {
	return &Factory{}
}

func (f *Factory) NewAccount(mods ...AccountMod) *AccountTemplate {
	return f.NewAccountWithContext(context.Background(), mods...)
}

func (f *Factory) NewAccountWithContext(ctx context.Context, mods ...AccountMod) *AccountTemplate {
	o := &AccountTemplate{f: f}

	if f != nil {
		f.baseAccountMods.Apply(ctx, o)
	}

	AccountModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingAccount(m *models.Account) *AccountTemplate {
	o := &AccountTemplate{f: f, alreadyPersisted: true}

	o.ID = func() types.Uint64 { return m.ID }
	o.ExternalAccountID = func() string { return m.ExternalAccountID }
	o.TenantID = func() types.Uint64 { return m.TenantID }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.Tenant != nil {
		AccountMods.WithExistingTenant(m.R.Tenant).Apply(ctx, o)
	}
	if len(m.R.OneShotUsages) > 0 {
		AccountMods.AddExistingOneShotUsages(m.R.OneShotUsages...).Apply(ctx, o)
	}
	if len(m.R.ServiceCharges) > 0 {
		AccountMods.AddExistingServiceCharges(m.R.ServiceCharges...).Apply(ctx, o)
	}
	if len(m.R.Subscriptions) > 0 {
		AccountMods.AddExistingSubscriptions(m.R.Subscriptions...).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewCatalogPrice(mods ...CatalogPriceMod) *CatalogPriceTemplate {
	return f.NewCatalogPriceWithContext(context.Background(), mods...)
}

func (f *Factory) NewCatalogPriceWithContext(ctx context.Context, mods ...CatalogPriceMod) *CatalogPriceTemplate {
	o := &CatalogPriceTemplate{f: f}

	if f != nil {
		f.baseCatalogPriceMods.Apply(ctx, o)
	}

	CatalogPriceModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingCatalogPrice(m *models.CatalogPrice) *CatalogPriceTemplate {
	o := &CatalogPriceTemplate{f: f, alreadyPersisted: true}

	o.ID = func() types.Uint64 { return m.ID }
	o.CatalogID = func() types.Uint64 { return m.CatalogID }
	o.Amount = func() int64 { return m.Amount }
	o.BillingType = func() enums.CatalogPricesBillingType { return m.BillingType }
	o.BillingCycle = func() sql.Null[enums.CatalogPricesBillingCycle] { return m.BillingCycle }
	o.StartDate = func() time.Time { return m.StartDate }
	o.EndDate = func() sql.Null[time.Time] { return m.EndDate }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.Catalog != nil {
		CatalogPriceMods.WithExistingCatalog(m.R.Catalog).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewCatalog(mods ...CatalogMod) *CatalogTemplate {
	return f.NewCatalogWithContext(context.Background(), mods...)
}

func (f *Factory) NewCatalogWithContext(ctx context.Context, mods ...CatalogMod) *CatalogTemplate {
	o := &CatalogTemplate{f: f}

	if f != nil {
		f.baseCatalogMods.Apply(ctx, o)
	}

	CatalogModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingCatalog(m *models.Catalog) *CatalogTemplate {
	o := &CatalogTemplate{f: f, alreadyPersisted: true}

	o.ID = func() types.Uint64 { return m.ID }
	o.Name = func() string { return m.Name }
	o.TenantID = func() types.Uint64 { return m.TenantID }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if len(m.R.CatalogPrices) > 0 {
		CatalogMods.AddExistingCatalogPrices(m.R.CatalogPrices...).Apply(ctx, o)
	}
	if m.R.Tenant != nil {
		CatalogMods.WithExistingTenant(m.R.Tenant).Apply(ctx, o)
	}
	if len(m.R.OneShotUsages) > 0 {
		CatalogMods.AddExistingOneShotUsages(m.R.OneShotUsages...).Apply(ctx, o)
	}
	if len(m.R.Subscriptions) > 0 {
		CatalogMods.AddExistingSubscriptions(m.R.Subscriptions...).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewOneShotUsage(mods ...OneShotUsageMod) *OneShotUsageTemplate {
	return f.NewOneShotUsageWithContext(context.Background(), mods...)
}

func (f *Factory) NewOneShotUsageWithContext(ctx context.Context, mods ...OneShotUsageMod) *OneShotUsageTemplate {
	o := &OneShotUsageTemplate{f: f}

	if f != nil {
		f.baseOneShotUsageMods.Apply(ctx, o)
	}

	OneShotUsageModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingOneShotUsage(m *models.OneShotUsage) *OneShotUsageTemplate {
	o := &OneShotUsageTemplate{f: f, alreadyPersisted: true}

	o.ID = func() types.Uint64 { return m.ID }
	o.AccountID = func() types.Uint64 { return m.AccountID }
	o.CatalogID = func() types.Uint64 { return m.CatalogID }
	o.IdempotencyKey = func() string { return m.IdempotencyKey }
	o.UsedAt = func() time.Time { return m.UsedAt }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.Account != nil {
		OneShotUsageMods.WithExistingAccount(m.R.Account).Apply(ctx, o)
	}
	if m.R.Catalog != nil {
		OneShotUsageMods.WithExistingCatalog(m.R.Catalog).Apply(ctx, o)
	}
	if len(m.R.ServiceChargeItems) > 0 {
		OneShotUsageMods.AddExistingServiceChargeItems(m.R.ServiceChargeItems...).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewSchemaMigration(mods ...SchemaMigrationMod) *SchemaMigrationTemplate {
	return f.NewSchemaMigrationWithContext(context.Background(), mods...)
}

func (f *Factory) NewSchemaMigrationWithContext(ctx context.Context, mods ...SchemaMigrationMod) *SchemaMigrationTemplate {
	o := &SchemaMigrationTemplate{f: f}

	if f != nil {
		f.baseSchemaMigrationMods.Apply(ctx, o)
	}

	SchemaMigrationModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingSchemaMigration(m *models.SchemaMigration) *SchemaMigrationTemplate {
	o := &SchemaMigrationTemplate{f: f, alreadyPersisted: true}

	o.Version = func() int64 { return m.Version }
	o.Dirty = func() bool { return m.Dirty }

	return o
}

func (f *Factory) NewServiceChargeItem(mods ...ServiceChargeItemMod) *ServiceChargeItemTemplate {
	return f.NewServiceChargeItemWithContext(context.Background(), mods...)
}

func (f *Factory) NewServiceChargeItemWithContext(ctx context.Context, mods ...ServiceChargeItemMod) *ServiceChargeItemTemplate {
	o := &ServiceChargeItemTemplate{f: f}

	if f != nil {
		f.baseServiceChargeItemMods.Apply(ctx, o)
	}

	ServiceChargeItemModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingServiceChargeItem(m *models.ServiceChargeItem) *ServiceChargeItemTemplate {
	o := &ServiceChargeItemTemplate{f: f, alreadyPersisted: true}

	o.ID = func() types.Uint64 { return m.ID }
	o.Name = func() string { return m.Name }
	o.Amount = func() int64 { return m.Amount }
	o.ServiceChargeID = func() types.Uint64 { return m.ServiceChargeID }
	o.OneShotUsageID = func() sql.Null[types.Uint64] { return m.OneShotUsageID }
	o.SubscriptionID = func() sql.Null[types.Uint64] { return m.SubscriptionID }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if m.R.ServiceCharge != nil {
		ServiceChargeItemMods.WithExistingServiceCharge(m.R.ServiceCharge).Apply(ctx, o)
	}
	if m.R.OneShotUsage != nil {
		ServiceChargeItemMods.WithExistingOneShotUsage(m.R.OneShotUsage).Apply(ctx, o)
	}
	if m.R.Subscription != nil {
		ServiceChargeItemMods.WithExistingSubscription(m.R.Subscription).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewServiceChargeStatus(mods ...ServiceChargeStatusMod) *ServiceChargeStatusTemplate {
	return f.NewServiceChargeStatusWithContext(context.Background(), mods...)
}

func (f *Factory) NewServiceChargeStatusWithContext(ctx context.Context, mods ...ServiceChargeStatusMod) *ServiceChargeStatusTemplate {
	o := &ServiceChargeStatusTemplate{f: f}

	if f != nil {
		f.baseServiceChargeStatusMods.Apply(ctx, o)
	}

	ServiceChargeStatusModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingServiceChargeStatus(m *models.ServiceChargeStatus) *ServiceChargeStatusTemplate {
	o := &ServiceChargeStatusTemplate{f: f, alreadyPersisted: true}

	o.ID = func() types.Uint64 { return m.ID }
	o.Name = func() string { return m.Name }
	o.Status = func() enums.ServiceChargeStatusesStatus { return m.Status }
	o.ServiceChargeID = func() types.Uint64 { return m.ServiceChargeID }
	o.CreatedAt = func() time.Time { return m.CreatedAt }

	ctx := context.Background()
	if m.R.ServiceCharge != nil {
		ServiceChargeStatusMods.WithExistingServiceCharge(m.R.ServiceCharge).Apply(ctx, o)
	}
	if len(m.R.LatestStatusServiceCharges) > 0 {
		ServiceChargeStatusMods.AddExistingLatestStatusServiceCharges(m.R.LatestStatusServiceCharges...).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewServiceCharge(mods ...ServiceChargeMod) *ServiceChargeTemplate {
	return f.NewServiceChargeWithContext(context.Background(), mods...)
}

func (f *Factory) NewServiceChargeWithContext(ctx context.Context, mods ...ServiceChargeMod) *ServiceChargeTemplate {
	o := &ServiceChargeTemplate{f: f}

	if f != nil {
		f.baseServiceChargeMods.Apply(ctx, o)
	}

	ServiceChargeModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingServiceCharge(m *models.ServiceCharge) *ServiceChargeTemplate {
	o := &ServiceChargeTemplate{f: f, alreadyPersisted: true}

	o.ID = func() types.Uint64 { return m.ID }
	o.AccountID = func() types.Uint64 { return m.AccountID }
	o.StartDate = func() time.Time { return m.StartDate }
	o.EndDate = func() time.Time { return m.EndDate }
	o.Amount = func() int64 { return m.Amount }
	o.LatestStatusID = func() sql.Null[types.Uint64] { return m.LatestStatusID }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if len(m.R.ServiceChargeItems) > 0 {
		ServiceChargeMods.AddExistingServiceChargeItems(m.R.ServiceChargeItems...).Apply(ctx, o)
	}
	if len(m.R.ServiceChargeStatuses) > 0 {
		ServiceChargeMods.AddExistingServiceChargeStatuses(m.R.ServiceChargeStatuses...).Apply(ctx, o)
	}
	if m.R.Account != nil {
		ServiceChargeMods.WithExistingAccount(m.R.Account).Apply(ctx, o)
	}
	if m.R.LatestStatusServiceChargeStatus != nil {
		ServiceChargeMods.WithExistingLatestStatusServiceChargeStatus(m.R.LatestStatusServiceChargeStatus).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewSubscription(mods ...SubscriptionMod) *SubscriptionTemplate {
	return f.NewSubscriptionWithContext(context.Background(), mods...)
}

func (f *Factory) NewSubscriptionWithContext(ctx context.Context, mods ...SubscriptionMod) *SubscriptionTemplate {
	o := &SubscriptionTemplate{f: f}

	if f != nil {
		f.baseSubscriptionMods.Apply(ctx, o)
	}

	SubscriptionModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingSubscription(m *models.Subscription) *SubscriptionTemplate {
	o := &SubscriptionTemplate{f: f, alreadyPersisted: true}

	o.ID = func() types.Uint64 { return m.ID }
	o.AccountID = func() types.Uint64 { return m.AccountID }
	o.CatalogID = func() types.Uint64 { return m.CatalogID }
	o.StartDate = func() time.Time { return m.StartDate }
	o.EndDate = func() sql.Null[time.Time] { return m.EndDate }
	o.IdempotencyKey = func() string { return m.IdempotencyKey }
	o.NextBillingDate = func() time.Time { return m.NextBillingDate }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if len(m.R.ServiceChargeItems) > 0 {
		SubscriptionMods.AddExistingServiceChargeItems(m.R.ServiceChargeItems...).Apply(ctx, o)
	}
	if m.R.Account != nil {
		SubscriptionMods.WithExistingAccount(m.R.Account).Apply(ctx, o)
	}
	if m.R.Catalog != nil {
		SubscriptionMods.WithExistingCatalog(m.R.Catalog).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewTenant(mods ...TenantMod) *TenantTemplate {
	return f.NewTenantWithContext(context.Background(), mods...)
}

func (f *Factory) NewTenantWithContext(ctx context.Context, mods ...TenantMod) *TenantTemplate {
	o := &TenantTemplate{f: f}

	if f != nil {
		f.baseTenantMods.Apply(ctx, o)
	}

	TenantModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingTenant(m *models.Tenant) *TenantTemplate {
	o := &TenantTemplate{f: f, alreadyPersisted: true}

	o.ID = func() types.Uint64 { return m.ID }
	o.Name = func() string { return m.Name }
	o.CreatedAt = func() time.Time { return m.CreatedAt }
	o.UpdatedAt = func() time.Time { return m.UpdatedAt }

	ctx := context.Background()
	if len(m.R.Accounts) > 0 {
		TenantMods.AddExistingAccounts(m.R.Accounts...).Apply(ctx, o)
	}
	if len(m.R.Catalogs) > 0 {
		TenantMods.AddExistingCatalogs(m.R.Catalogs...).Apply(ctx, o)
	}

	return o
}

func (f *Factory) ClearBaseAccountMods() {
	f.baseAccountMods = nil
}

func (f *Factory) AddBaseAccountMod(mods ...AccountMod) {
	f.baseAccountMods = append(f.baseAccountMods, mods...)
}

func (f *Factory) ClearBaseCatalogPriceMods() {
	f.baseCatalogPriceMods = nil
}

func (f *Factory) AddBaseCatalogPriceMod(mods ...CatalogPriceMod) {
	f.baseCatalogPriceMods = append(f.baseCatalogPriceMods, mods...)
}

func (f *Factory) ClearBaseCatalogMods() {
	f.baseCatalogMods = nil
}

func (f *Factory) AddBaseCatalogMod(mods ...CatalogMod) {
	f.baseCatalogMods = append(f.baseCatalogMods, mods...)
}

func (f *Factory) ClearBaseOneShotUsageMods() {
	f.baseOneShotUsageMods = nil
}

func (f *Factory) AddBaseOneShotUsageMod(mods ...OneShotUsageMod) {
	f.baseOneShotUsageMods = append(f.baseOneShotUsageMods, mods...)
}

func (f *Factory) ClearBaseSchemaMigrationMods() {
	f.baseSchemaMigrationMods = nil
}

func (f *Factory) AddBaseSchemaMigrationMod(mods ...SchemaMigrationMod) {
	f.baseSchemaMigrationMods = append(f.baseSchemaMigrationMods, mods...)
}

func (f *Factory) ClearBaseServiceChargeItemMods() {
	f.baseServiceChargeItemMods = nil
}

func (f *Factory) AddBaseServiceChargeItemMod(mods ...ServiceChargeItemMod) {
	f.baseServiceChargeItemMods = append(f.baseServiceChargeItemMods, mods...)
}

func (f *Factory) ClearBaseServiceChargeStatusMods() {
	f.baseServiceChargeStatusMods = nil
}

func (f *Factory) AddBaseServiceChargeStatusMod(mods ...ServiceChargeStatusMod) {
	f.baseServiceChargeStatusMods = append(f.baseServiceChargeStatusMods, mods...)
}

func (f *Factory) ClearBaseServiceChargeMods() {
	f.baseServiceChargeMods = nil
}

func (f *Factory) AddBaseServiceChargeMod(mods ...ServiceChargeMod) {
	f.baseServiceChargeMods = append(f.baseServiceChargeMods, mods...)
}

func (f *Factory) ClearBaseSubscriptionMods() {
	f.baseSubscriptionMods = nil
}

func (f *Factory) AddBaseSubscriptionMod(mods ...SubscriptionMod) {
	f.baseSubscriptionMods = append(f.baseSubscriptionMods, mods...)
}

func (f *Factory) ClearBaseTenantMods() {
	f.baseTenantMods = nil
}

func (f *Factory) AddBaseTenantMod(mods ...TenantMod) {
	f.baseTenantMods = append(f.baseTenantMods, mods...)
}
